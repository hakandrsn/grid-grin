This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: assets
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.agent/rules/block-puzzle-core.md
.agent/rules/global-standards.md
.agent/rules/global-ts-standards.md
.agent/skills/game-architect.md
.agent/skills/game-mechanics-master/SKILL.md
.agent/workflows/polish-to-final.md
.github/workflows/ios-build.yml
.gitignore
app.json
app/_layout.tsx
app/game.tsx
app/index.tsx
eas.json
eslint.config.js
issues.md
package.json
README.md
services/adManager.ts
src/components/ads/ChapterNativeAd.tsx
src/components/ads/GameBannerAd.tsx
src/components/Board.tsx
src/components/Cell.tsx
src/components/GameOverOverlay.tsx
src/components/Piece.tsx
src/components/PuffExplosion.tsx
src/components/ScoreBoard.tsx
src/components/Splash/CustomSplashScreen.tsx
src/components/StreakOverlay.tsx
src/store/adStore.ts
src/store/useGameStore.ts
src/types/index.ts
src/utils/constants.ts
src/utils/gameLogic.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".agent/rules/block-puzzle-core.md">
---
trigger: always_on
---

# Block Puzzle Final Mechanics

**Goal**: Kusursuz "snapping" ve ak캼c캼 "puff" animasyonlar캼.

## Interaction Rules

- **Finger Offset**: Kullan캼c캼 parma캼 ile par칞ay캼 tuttu릇n parma캼n alt캼nda kalmal캼 ve par칞ay캼 bo alana g칬t칲rebilmeli.
- **Snapping Logic**: Par칞a, hedef h칲zzrenin %40'캼na girdi를nde m캼knat캼s gibi 칞ekebilmeli.
- **Move Logic**: bir par칞ay캼 s칲r칲klerken dolu h칲creler 칲st칲nden s칲r칲klenebilir olmal캼 ama 칲st칲nde ike koyamaca캼n캼 belirgin 른kilde g칬stermelidir.
- **Puff Animation**: Sat캼r/s칲tun silindi를nde h칲creler `150ms` i칞inde k칲칞칲lerek yok olmal캼; bu esnada grid arka plan캼 (`emptyGrid`) her zaman g칬r칲n칲r kalmal캼d캼r.

## Scoring & Progression

- **Streak System**: Arka arkaya yap캼lan her ba르r캼l캼 hamle, `currentStreak * 1.5` 칞arpan캼yla 칬d칲llendirilmelidir.
- **GameOver**: `availablePieces` i칞indeki hi칞bir par칞a board'a s캼릀ad캼캼nda `isGameOver` an캼nda tetiklenmelidir.
- **Scrore**: Puanlama, streak kazan캼m캼, yok edilen par칞alar gibi ayr캼 칬zellikler utils de tutulmal캼 ve her biri y칲ksek performans ile kurulmal캼.
</file>

<file path=".agent/rules/global-standards.md">
---
trigger: always_on
---

# Antigravity Global Standards

**Goal**: En y칲ksek FPS ve en d칲칲k teknik bor칞 ile oyun geli릆irme.

## Technical Constraints

- **State Management**: T칲m oyun mant캼캼 (Board, Score, GameState) `src/store/useGameStore.ts` i칞inde merkezi olarak y칬netilmelidir.
- **UI Performance**:
  - Board i칞indeki her `Cell` mutlaka `memo` ile sarmalanmal캼d캼r.
  - Animasyonlar sadece `react-native-reanimated` (v4+) 칲zerinden `useSharedValue` ve `useAnimatedStyle` ile yap캼lmal캼d캼r.
- **Coordinate Integrity**: S칲r칲kle-b캼rak i륿emlerinde `measureInWindow` kullan캼larak mutlak koordinat senkronizasyonu her zaman korunmal캼d캼r.
</file>

<file path=".agent/rules/global-ts-standards.md">
---
trigger: always_on
---

Dil ve Stack: Her zaman TypeScript kullan캼lmal캼, mobil aray칲zlerde React Native + Expo tercih edilmelidir.

State Y칬netimi: Karma캼k UI durumlar캼 yerine her zaman Zustand store kullan캼lmal캼, "logic" ve "view" katmanlar캼 ayr캼lmal캼d캼r.

Performans: Animasyonlar i칞in react-native-reanimated kullan캼lmal캼 ve gereksiz render'lar캼 칬nlemek i칞in memo ve useSharedValue optimizasyonlar캼 zorunlu tutulmal캼d캼r.

Methods: birden fazla yerde kullan캼lacak utils methodlar캼 utils/ alt캼nda toplanmal캼

Components & UI: Her par칞a ui eleman캼 component i칞inde tan캼mlanmal캼, business olanlarda components/business dosyas캼 i칞inde tan캼mlanmal캼
</file>

<file path=".agent/skills/game-architect.md">
# Antigravity Game Architect Skill

**Description**: Karma캼k oyun motoru g칲ncellemelerini ve performans optimizasyonlar캼n캼 y칬netme yetene를.

## Capabilities

1. **Logic Implementation**: `src/utils/gameLogic.ts` i칞indeki silme ve puanlama algoritmalar캼n캼 `Rules` setine g칬re hatas캼z g칲nceller.
2. **Haptic Service**: `expo-haptics` kullanarak her "snap", "clear" ve "gameover" durumunda doru titre를m geri bildirimlerini entegre eder.
3. **Persistence Master**: `AsyncStorage` kullanarak `bestScore` ve `gameState` verilerini kal캼c캼 olarak saklar.
4. **Animation Tuning**: Reanimated easing fonksiyonlar캼n캼 (Easing.out(Easing.quad)) kullanarak "yaylanmayan" ama ak캼c캼 d칬n칲 animasyonlar캼 kurar.
</file>

<file path=".agent/skills/game-mechanics-master/SKILL.md">
# Block Puzzle Mechanics Master

**Description**: Grid snapping, score calculation, and piece generation logic management.

## Instructions

- Grid yerle를mi hesaplan캼rken `Math.round` ile en yak캼n h칲creyi bul.
- Yeni par칞a (shape) 칲retirken `src/utils/constants.ts` i칞indeki tan캼mlar캼 baz al.
- Score hesaplamas캼nda streak bonuslar캼n캼 `processMove` algoritmas캼na g칬re uygula.
- Animasyonlarda react-native-reanimated kullan.
-

## Constraints

- Do not modify cell opacity directly without checking if it's a permanent block or a preview.
- Always verify boardLayout coordinates before updating store state.
</file>

<file path=".agent/workflows/polish-to-final.md">
---
description: Projeyi tamamlanm캼, markete 칞캼kmaya haz캼r hale getirecek i ak캼륿ar캼.
---

# Workflow: Road to Final Release

**Steps**:

1. **Coordinate Audit**: Board ve Piece koordinatlar캼n캼 `absoluteX/Y` 칲zerinden kalibre et.
2. **Asset Integration**: Splash screen ve icon dosyalar캼n캼 `app.json` standartlar캼na g칬re yerle릆ir.
3. **Animation Polish**: "Strike" durumlar캼nda Board 칲zerinde hafif sars캼nt캼 (Shake) ve parlama efektlerini devreye al.
4. **Ad-Network Prep**: 칐d칲ll칲 reklam (Rewarded Ads) i칞in `continueWithNewPieces` fonksiyonunu tetikleyecek UI butonunu stabilize et.
5. **Testing**: 12x12 grid 칲zerinde t칲m par칞alar캼n "Game Over" durumuna d칲칲칲n칲 manuel sim칲le et.
</file>

<file path=".github/workflows/ios-build.yml">
name: iOS Build
on:
  workflow_dispatch: # Bu build'i manuel tetiklemeni sa륿ar

jobs:
  build:
    runs-on: macos-latest
    steps:
      - name: 游끵 Checkout repository
        uses: actions/checkout@v4

      - name: 游끵 Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22.21.1
          cache: "npm"

      - name: 游끵 Setup Expo
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: 游닍 Install dependencies
        run: npm install

      - name: 游끵 Install EAS CLI
        run: npm install -g eas-cli

      - name: 游 Build iOS
        run: |
          eas build --platform ios --profile production --local --non-interactive --output ios-build.ipa
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}

      - name: 游꼝 Submit to App Store
        run: |
          eas submit --platform ios --path ios-build.ipa --profile production --non-interactive --no-wait
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}

      - name: 游닋 Upload Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ios-build
          path: |
            *.ipa
            *.tar.gz
</file>

<file path="app/game.tsx">
import GameBannerAd from "@/src/components/ads/GameBannerAd";
import { GameOverOverlay } from "@/src/components/GameOverOverlay";
import Piece from "@/src/components/Piece";
import { StreakOverlay } from "@/src/components/StreakOverlay";
import { useGameStore } from "@/src/store/useGameStore";
import { Ionicons } from "@expo/vector-icons";
import { useRouter } from "expo-router";
import React, { useEffect, useRef } from "react";
import { AppState, StyleSheet, TouchableOpacity, View } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Board } from "../src/components/Board";
import { ScoreBoard } from "../src/components/ScoreBoard";
import { THEME } from "../src/utils/constants";

export default function Game() {
  const { top } = useSafeAreaInsets();
  const router = useRouter();
  const appState = useRef(AppState.currentState);
  const availablePieces = useGameStore((state) => state.availablePieces);
  const isGameOver = useGameStore((state) => state.isGameOver);
  const refreshPieces = useGameStore((state) => state.refreshPieces);
  const resetGame = useGameStore((state) => state.resetGame);
  const continueWithNewPieces = useGameStore(
    (state) => state.continueWithNewPieces,
  );
  const saveGame = useGameStore((state) => state.saveGame);

  // Initial Load (if coming directly or reload)
  useEffect(() => {
    // Safety check: If no pieces are present (e.g. fresh reload directly to game), generate them.
    if (availablePieces.length === 0 && !isGameOver) {
      refreshPieces();
    }

    // AppState listener for Autosave
    const subscription = AppState.addEventListener("change", (nextAppState) => {
      if (
        appState.current.match(/inactive|background/) &&
        nextAppState === "active"
      ) {
        // App returned to foreground
      } else if (nextAppState.match(/inactive|background/)) {
        // App going to background -> Save
        saveGame();
      }
      appState.current = nextAppState;
    });

    return () => {
      saveGame(); // Also save on unmount (back to menu)
      subscription.remove();
    };
  }, [availablePieces.length, isGameOver, refreshPieces, saveGame]);

  const handleBack = async () => {
    await saveGame();
    router.replace("/");
  };

  return (
    <View style={[styles.container]}>
      <View style={{ flex: 1, paddingTop: top }}>
        {/* Header Area */}
        <View style={styles.header}>
          {/* Back Button (Left) */}
          <TouchableOpacity
            onPress={handleBack}
            style={styles.headerButton}
            activeOpacity={0.7}
            hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
          >
            <Ionicons name="arrow-back" size={24} color="#fff" />
          </TouchableOpacity>

          {/* ScoreBoard (Center) */}
          <ScoreBoard />

          {/* Restart Button (Right) */}
          <TouchableOpacity
            onPress={resetGame}
            style={styles.headerButton}
            activeOpacity={0.7}
            hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
          >
            <Ionicons name="refresh" size={24} color="#fff" />
          </TouchableOpacity>
        </View>

        <View style={styles.gameArea}>
          <Board />
        </View>
        <View style={styles.pieceArea}>
          {availablePieces.map((piece) => (
            <View key={piece.id} style={styles.pieceContainer}>
              <Piece {...piece} />
            </View>
          ))}
        </View>
      </View>

      {/* Banner Ad Section */}
      <View
        style={{
          backgroundColor: THEME.BACKGROUND,
          width: "100%",
        }}
      >
        <GameBannerAd />
      </View>

      <StreakOverlay />

      {isGameOver && (
        <GameOverOverlay
          onContinue={continueWithNewPieces}
          onReset={resetGame}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: THEME.BACKGROUND,
    alignItems: "center",
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 20,
    width: "100%",
  },
  headerButton: {
    padding: 12,
    backgroundColor: THEME.SURFACE_LIGHT, // Lighter than BG
    borderRadius: 16,
    // borderWidth: 1, // Removed border for cleaner look, or keep?
    // borderColor: "rgba(255,255,255,0.05)",
  },
  gameArea: {
    flex: 1, // Allow board to take available space (constrained by CELL_SIZE)
    justifyContent: "center",
    alignItems: "center",
  },
  pieceArea: {
    height: 150,
    width: "100%",
    // Background removed
    justifyContent: "space-around",
    alignItems: "center",
    flexDirection: "row",
    paddingBottom: 20, // Push slightly up
  },
  pieceContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    height: "100%",
  },
  gameOverOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.85)",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 2000,
  },
  gameOverText: { color: "#fff", fontSize: 40, fontWeight: "900" },
  // resetButton removed (duplicate)
  resetButtonText: { color: "#000", fontWeight: "bold", fontSize: 18 },
  gameOverTitle: {
    color: "#fff",
    fontSize: 44,
    fontWeight: "900",
    marginBottom: 10,
  },
  finalScoreText: {
    color: "#00ffcc",
    fontSize: 60,
    fontWeight: "900",
    marginBottom: 40,
  },
  buttonContainer: { width: "80%", gap: 15 },
  actionButton: { padding: 20, borderRadius: 15, alignItems: "center" },
  actionButtonText: { color: "#000", fontWeight: "bold", fontSize: 16 },
});
</file>

<file path="eas.json">
{
  "cli": {
    "version": ">= 16.28.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "channel": "development",
      "autoIncrement": true
    },
    "preview": {
      "channel": "preview",
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "channel": "production",
      "autoIncrement": true,
      "distribution": "store"
    }
  },
  "submit": {
    "production": {
      "ios": {
        "ascAppId": "6758456888"
      }
    }
  }
}
</file>

<file path="eslint.config.js">
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);
</file>

<file path="issues.md">
### sorunlar (칞칬z칲lmesi gerekenler, 칞칬z칲lenelre tik at캼lacak)

- [x] gameover oldu릇nda yeni par칞alarla devam et diyor ve yeni par칞a al캼yoruz ama gelen par칞alarda olmuyor burada stack kal캼yoruz.
- [x] dikey ya da yatayda par칞alar yok oldu릇 zaman puff animasyonu 칞캼kmas캼n캼 istiyorum burada lottie kullanmak istiyorum (alternatif yvarsa o da olur 칬nerielre a칞캼캼m buraya not al)
- [x] strike sayac캼 ehr zaman g칬r칲n칲r olsun ve say캼s캼na g칬re alevli felan olacakt캼r lottie ekleriz + her strike da daha iyi bir animasyon koyar캼z bunlar캼 performansl캼 olacak 른kilde yerle릆irmek gerek.
- [x] board un 칞er칞evesi strike a g칬re yan캼p s칬necek 른kilde animasyon olmal캼
- [ ] her 른klin rengi farkl캼 olabilir random daha fazla renk ama bir t캼k daha az parlak olabilir. g칬z yormas캼n fazla.
- [ ] oyun alan캼 board biraz daha yukar캼da olacak par칞alarda oyun alan캼n캼n alt캼nda olacak. en alt k캼s캼m reklam i칞in rezerve edilecek
- [ ] oyun background al캼n캼rsa an캼nda localstorage a save edilecek mevcut durum geri gelindi를nde kald캼캼 yerden devam edecek
- [ ] best score her zaman g칲ncel oyun bitince kaydedilecke ve ekranda g칬r칲nt칲lecek
- [ ] strike say캼s캼na g칬re ekranda kayan yaz캼lar ge칞ecek (image de olabilir png ileride ekrana h캼zl캼ca gelecek bi anl캼k duracak ve tekrar gidecek pointer none olacak)
</file>

<file path="services/adManager.ts">
import { useAdStore } from "@/src/store/adStore";
import { AD_CONFIG } from "@/src/utils/constants";
import { Platform } from "react-native";
import { MaxAdContentRating } from "react-native-google-mobile-ads";

// ==========================================
// CHECK IF ADMOB IS AVAILABLE
// ==========================================

let isAdMobAvailable = false;
let InterstitialAd: any = null;
let RewardedAd: any = null;
let AdEventType: any = null;
let RewardedAdEventType: any = null;
let TestIds: any = null;

try {
  const admob = require("react-native-google-mobile-ads");
  InterstitialAd = admob.InterstitialAd;
  RewardedAd = admob.RewardedAd;
  AdEventType = admob.AdEventType;
  RewardedAdEventType = admob.RewardedAdEventType;
  TestIds = admob.TestIds;
  isAdMobAvailable = true;
  console.log("游닠 AdMob module loaded");
} catch (error) {
  console.log("游닠 AdMob not available (Expo Go or not configured)");
  isAdMobAvailable = false;
}

// ==========================================
// AD UNIT IDS
// ==========================================

const getInterstitialId = () => {
  if (__DEV__ && TestIds) return TestIds.INTERSTITIAL;
  return Platform.OS === "ios"
    ? AD_CONFIG.interstitial.ios
    : AD_CONFIG.interstitial.android;
};

const getRewardedId = () => {
  if (__DEV__ && TestIds) return TestIds.REWARDED;
  return Platform.OS === "ios"
    ? AD_CONFIG.rewarded.ios
    : AD_CONFIG.rewarded.android;
};

// ==========================================
// AD INSTANCES
// ==========================================

let interstitialAd: any = null;
let rewardedAd: any = null;
let isInterstitialLoaded = false;
let isRewardedLoaded = false;

// ==========================================
// INTERSTITIAL ADS
// ==========================================

export const loadInterstitial = () => {
  if (!isAdMobAvailable || !InterstitialAd) {
    console.log("游닠 AdMob not available, skipping interstitial load");
    return;
  }

  try {
    interstitialAd = InterstitialAd.createForAdRequest(getInterstitialId());

    interstitialAd.addAdEventListener(AdEventType.LOADED, () => {
      isInterstitialLoaded = true;
      useAdStore.getState().actions.setInterstitialReady(true);
      console.log("游닠 Interstitial loaded");
    });

    interstitialAd.addAdEventListener(AdEventType.CLOSED, () => {
      isInterstitialLoaded = false;
      useAdStore.getState().actions.setInterstitialReady(false);
      loadInterstitial(); // Preload next
    });

    interstitialAd.addAdEventListener(AdEventType.ERROR, (error: any) => {
      console.log("游닠 Interstitial error:", error);
      isInterstitialLoaded = false;
      useAdStore.getState().actions.setInterstitialReady(false);
    });

    interstitialAd.load();
  } catch (error) {
    console.log("游닠 Interstitial init error:", error);
  }
};

export const showInterstitial = async (): Promise<boolean> => {
  if (!isAdMobAvailable || !isInterstitialLoaded || !interstitialAd) {
    console.log("游닠 Interstitial not ready");
    return false;
  }

  return new Promise((resolve) => {
    try {
      // Listen for ad close event BEFORE showing
      const closeListener = interstitialAd.addAdEventListener(
        AdEventType.CLOSED,
        () => {
          console.log("游닠 Interstitial closed by user");
          useAdStore.getState().actions.setAdShowing(false); // Enable other ads
          closeListener(); // Remove listener
          resolve(true); // Ad was watched
        },
      );

      // Also handle errors
      const errorListener = interstitialAd.addAdEventListener(
        AdEventType.ERROR,
        () => {
          console.log("游닠 Interstitial error during show");
          errorListener();
          resolve(false);
        },
      );

      interstitialAd.show();
      useAdStore.getState().actions.setAdShowing(true); // Disable other ads
      useAdStore.getState().actions.markInterstitialShown();
    } catch (error) {
      console.log("游닠 Interstitial show error:", error);
      useAdStore.getState().actions.setAdShowing(false); // Reset on error
      resolve(false);
    }
  });
};

// ==========================================
// REWARDED ADS
// ==========================================

export const loadRewarded = () => {
  if (!isAdMobAvailable || !RewardedAd) {
    console.log("游닠 AdMob not available, skipping rewarded load");
    return;
  }

  try {
    rewardedAd = RewardedAd.createForAdRequest(getRewardedId());

    rewardedAd.addAdEventListener(RewardedAdEventType.LOADED, () => {
      isRewardedLoaded = true;
      useAdStore.getState().actions.setRewardedReady(true);
      console.log("游꾸 Rewarded loaded");
    });

    rewardedAd.addAdEventListener(RewardedAdEventType.EARNED_REWARD, () => {
      console.log("游꾸 Reward earned");
    });

    rewardedAd.addAdEventListener(AdEventType.CLOSED, () => {
      isRewardedLoaded = false;
      useAdStore.getState().actions.setRewardedReady(false);
      loadRewarded(); // Preload next
    });

    rewardedAd.addAdEventListener(AdEventType.ERROR, (error: any) => {
      console.log("游꾸 Rewarded error:", error);
      isRewardedLoaded = false;
      useAdStore.getState().actions.setRewardedReady(false);
    });

    rewardedAd.load();
  } catch (error) {
    console.log("游꾸 Rewarded init error:", error);
  }
};

export const showRewarded = (): Promise<boolean> => {
  if (!isAdMobAvailable || !isRewardedLoaded || !rewardedAd) {
    console.log("游꾸 Rewarded not ready");
    return Promise.resolve(false);
  }

  return new Promise((resolve) => {
    const unsubscribeReward = rewardedAd.addAdEventListener(
      RewardedAdEventType.EARNED_REWARD,
      () => {
        unsubscribeReward();
        useAdStore.getState().actions.setAdShowing(false);
        useAdStore.getState().actions.markRewardedShown();
        resolve(true);
      },
    );

    const unsubscribeClose = rewardedAd.addAdEventListener(
      AdEventType.CLOSED,
      () => {
        unsubscribeClose();
        useAdStore.getState().actions.setAdShowing(false);
      },
    );

    const unsubscribeError = rewardedAd.addAdEventListener(
      AdEventType.ERROR,
      () => {
        unsubscribeError();
        useAdStore.getState().actions.setAdShowing(false);
        resolve(false);
      },
    );

    try {
      if (rewardedAd) {
        rewardedAd.show();
        useAdStore.getState().actions.setAdShowing(true);
      } else {
        throw new Error("Rewarded ad instance is null");
      }
    } catch (error) {
      console.log("游꾸 Rewarded show error:", error);
      useAdStore.getState().actions.setAdShowing(false);
      resolve(false);
    }
  });
};

// ==========================================
// INITIALIZATION
// ==========================================

// PERFORMANCE: Deferred initialization to prevent blocking splash/animations
export const initializeAds = () => {
  if (!isAdMobAvailable) {
    console.log("游닠 AdMob not available, skipping initialization");
    return;
  }

  // Defer ad loading to prevent JS bridge contention during startup
  // This allows splash screen and initial animations to complete smoothly
  setTimeout(() => {
    console.log("游닠 Initializing ads (deferred)...");

    // Families Policy Configuration
    if (isAdMobAvailable) {
      const mobileAds = require("react-native-google-mobile-ads").default;
      mobileAds()
        .setRequestConfiguration({
          // Child-directed setting
          tagForChildDirectedTreatment: true,
          // Under-age of consent setting
          tagForUnderAgeOfConsent: true,
          // Content rating: General audiences (G)
          maxAdContentRating: MaxAdContentRating.G,
        })
        .then(() => {
          console.log("游닠 AdMob configuration set for Families Policy");
        });
    }

    loadInterstitial();
    loadRewarded();
  }, 1500); // 1.5s delay after app is interactive
};

export const isInterstitialReady = () =>
  isAdMobAvailable && isInterstitialLoaded;
export const isRewardedReady = () => isAdMobAvailable && isRewardedLoaded;
</file>

<file path="src/components/ads/ChapterNativeAd.tsx">
import { AD_CONFIG } from "@/src/utils/constants";
import React from "react";
import { Platform, StyleSheet, View } from "react-native";

// ==========================================
// CHECK IF ADMOB IS AVAILABLE
// ==========================================

let isAdMobAvailable = false;
let BannerAd: any = null;
let BannerAdSize: any = null;
let TestIds: any = null;

try {
  const admob = require("react-native-google-mobile-ads");
  BannerAd = admob.BannerAd;
  BannerAdSize = admob.BannerAdSize;
  TestIds = admob.TestIds;
  isAdMobAvailable = true;
} catch (error) {
  console.log("游닠 AdMob not available for native ads");
  isAdMobAvailable = false;
}

// ==========================================
// NATIVE AD COMPONENT (Using Medium Rectangle Banner)
// ==========================================

interface ChapterNativeAdProps {
  index: number;
}

const ChapterNativeAd: React.FC<ChapterNativeAdProps> = ({ index }) => {
  if (!isAdMobAvailable || !BannerAd || !BannerAdSize) {
    // Fallback: Show nothing if AdMob not available
    return null;
  }

  const getBannerId = () => {
    if (__DEV__ && TestIds) return TestIds.BANNER;
    return Platform.OS === "ios"
      ? AD_CONFIG.banner.ios
      : AD_CONFIG.banner.android;
  };

  return (
    <View style={styles.adWrapper}>
      <BannerAd
        unitId={getBannerId()}
        size={BannerAdSize.MEDIUM_RECTANGLE}
        requestOptions={{
          requestNonPersonalizedAdsOnly: false,
        }}
        onAdLoaded={() => {
          console.log("游닠 Chapter ad loaded");
        }}
        onAdFailedToLoad={(error: any) => {
          console.log("游닠 Chapter ad failed:", error);
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  adWrapper: {
    width: "100%",
    alignItems: "center",
    marginVertical: 8,
  },
});

export default ChapterNativeAd;
</file>

<file path="src/components/ads/GameBannerAd.tsx">
import {
  useAdActions,
  useIsAdShowing,
  useIsBannerReady,
} from "@/src/store/adStore";
import { AD_CONFIG } from "@/src/utils/constants";
import React, { useEffect, useState } from "react";
import { Platform, StyleSheet, Text, View } from "react-native";

// ==========================================
// CHECK IF ADMOB IS AVAILABLE
// ==========================================

let isAdMobAvailable = false;
let BannerAd: any = null;
let BannerAdSize: any = null;
let TestIds: any = null;

try {
  const admob = require("react-native-google-mobile-ads");
  BannerAd = admob.BannerAd;
  BannerAdSize = admob.BannerAdSize;
  TestIds = admob.TestIds;
  isAdMobAvailable = true;
} catch (error) {
  console.log("游닠 AdMob not available for banner");
  isAdMobAvailable = false;
}

// ==========================================
// BANNER AD COMPONENT
// ==========================================

interface GameBannerAdProps {
  onAdLoaded?: () => void;
  onAdFailedToLoad?: () => void;
}

const GameBannerAd: React.FC<GameBannerAdProps> = ({
  onAdLoaded,
  onAdFailedToLoad,
}) => {
  const adActions = useAdActions();
  const isBannerReady = useIsBannerReady();
  const isAdShowing = useIsAdShowing();
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (isAdMobAvailable) {
      setIsVisible(true);
    }
  }, []);

  if (!isAdMobAvailable || !BannerAd || !BannerAdSize) {
    return null;
  }

  // Hide banner if a full-screen ad involves ensuring no multiple ads are shown
  if (isAdShowing) {
    return null;
  }

  const getBannerId = () => {
    if (__DEV__ && TestIds) return TestIds.BANNER;
    return Platform.OS === "ios"
      ? AD_CONFIG.banner.ios
      : AD_CONFIG.banner.android;
  };

  const handleAdLoaded = () => {
    console.log("游닠 Banner ad loaded");
    adActions.setBannerReady(true);
    onAdLoaded?.();
  };

  const handleAdFailedToLoad = (error: any) => {
    console.log("游닠 Banner ad failed to load:", error);
    adActions.setBannerReady(false);
    onAdFailedToLoad?.();
  };

  if (!isVisible) return null;

  return (
    <View style={styles.bannerContainer}>
      <Text style={styles.adLabel}>Reklam</Text>
      <View style={styles.adWrapper}>
        <BannerAd
          unitId={getBannerId()}
          size={BannerAdSize.ANCHORED_ADAPTIVE_BANNER}
          requestOptions={{
            requestNonPersonalizedAdsOnly: false,
          }}
          onAdLoaded={handleAdLoaded}
          onAdFailedToLoad={handleAdFailedToLoad}
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  bannerContainer: {
    width: "100%",
    alignItems: "center",
    paddingVertical: 10, // Add spacing around banner
  },
  adLabel: {
    fontSize: 10,
    color: "#fff",
    marginBottom: 4,
    opacity: 0.7,
  },
  adWrapper: {
    alignItems: "center",
    justifyContent: "center",
    minHeight: 50, // Minimum height for banner
  },
});

export default GameBannerAd;
</file>

<file path="src/components/Board.tsx">
// src/components/Board.tsx
import React, { useEffect, useRef } from "react";
import { StyleSheet, View } from "react-native";
import Animated, {
  interpolateColor,
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withTiming,
} from "react-native-reanimated";
import { useGameStore } from "../store/useGameStore";
import { THEME } from "../utils/constants";
import Cell from "./Cell";

export const Board = () => {
  const viewRef = useRef<View>(null);
  const setBoardLayout = useGameStore((state) => state.setBoardLayout);
  const board = useGameStore((state) => state.board);
  const streak = useGameStore((state) => state.streak);

  // Board titremesini kald캼r캼yoruz (User requested: "titreme olmas캼n board sabit kals캼n")
  const pulse = useSharedValue(0);

  useEffect(() => {
    // Streak varsa 칞er칞eve yan캼p s칬ns칲n (Pulsation)
    if (streak > 0) {
      pulse.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 600 }),
          withTiming(0.4, { duration: 600 }),
        ),
        -1, // Infinite repeat
        true, // Reverse
      );
    } else {
      pulse.value = 0; // Reset
    }
  }, [streak, pulse]);

  const animatedBorderStyle = useAnimatedStyle(() => {
    // Basit bir renk ge칞i를 (Streak yokken sabit, varken renkli)
    const baseColor = "#333";
    const activeColor = streak > 5 ? "#ffcc00" : "#00ffcc"; // High streak = Gold, Low = Green

    // Streak yoksa pulse etkisi olmas캼n
    const borderColor =
      streak > 0
        ? interpolateColor(pulse.value, [0, 1], [baseColor, activeColor])
        : baseColor;

    // G칬lge efekti de pulse ile uyumlu olsun
    const shadowOpacity = streak > 0 ? pulse.value * 0.8 : 0;
    const shadowRadius = streak > 0 ? 10 : 0;
    const borderWidth = streak > 0 ? 3 : 1; // Subtle border normally

    return {
      borderColor,
      borderWidth,
      shadowColor: activeColor,
      shadowOpacity,
      shadowRadius,
      shadowOffset: { width: 0, height: 0 },
      // transform: [{ translateX: shake.value }] // REMOVED SHAKE
    };
  });
  const handleLayout = () => {
    // Measure the exact position and size of the grid container
    setTimeout(() => {
      viewRef.current?.measureInWindow((x, y, width) => {
        if (width > 0) {
          // Store the top-left corner of the grid
          setBoardLayout({ x, y, size: width });
        }
      });
    }, 500); // Give it a bit more time to settle
  };
  return (
    <Animated.View
      ref={viewRef}
      onLayout={handleLayout}
      style={[styles.container, animatedBorderStyle]}
    >
      <View style={styles.gridInner}>
        {board.map((row, rIdx) => (
          <View key={rIdx} style={styles.row}>
            {row.map((cellColor, cIdx) => (
              <Cell
                key={`${rIdx}-${cIdx}`}
                row={rIdx}
                col={cIdx}
                color={cellColor}
              />
            ))}
          </View>
        ))}
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: THEME.SURFACE,
    borderRadius: 8,
    overflow: "hidden",
  },
  gridInner: {
    padding: 2, // Very minimal consistent padding
  },
  row: { flexDirection: "row" },
});
</file>

<file path="src/components/Cell.tsx">
// src/components/Cell.tsx
import React, { memo, useEffect, useRef } from "react";
import { Dimensions, StyleSheet, View } from "react-native";
import Animated, {
  Easing,
  useAnimatedStyle,
  useSharedValue,
  withSequence,
  withTiming,
} from "react-native-reanimated";
import { BOARD_SIZE } from "../utils/constants";

const { width } = Dimensions.get("window");
const CELL_SIZE = (width - 40) / BOARD_SIZE;

interface CellProps {
  row: number;
  col: number;
  color: string | null;
}

const Cell = ({ row, col, color }: CellProps) => {
  const blockScale = useSharedValue(color ? 1 : 0);
  const blockOpacity = useSharedValue(color ? 1 : 0);

  // Logic tracking for transitions
  const prevColor = useRef(color);

  // Visual persistence for clear animation
  const lastValidColor = useRef(color);
  if (color) lastValidColor.current = color;

  // Flash / Burst Animation State
  const flashScale = useSharedValue(0.8);
  const flashOpacity = useSharedValue(0);

  useEffect(() => {
    // 1. Silinme (Puff) & Flash Animasyonu
    if (color === null && prevColor.current !== null) {
      // Cell: Hafif칞e b칲y칲y칲p i칞ine 칞칬kme (Implosion effect)
      blockScale.value = withSequence(
        withTiming(1.1, { duration: 50 }),
        withTiming(0, { duration: 200, easing: Easing.inOut(Easing.quad) }),
      );
      blockOpacity.value = withTiming(0, { duration: 200 });

      // Flash: Patlama efekti (Daha derli toplu)
      flashScale.value = 0.8;
      flashOpacity.value = 1;

      flashScale.value = withTiming(1.4, {
        duration: 300,
        easing: Easing.out(Easing.quad),
      });
      flashOpacity.value = withTiming(0, { duration: 300 });
    }
    // 2. Yeni blok yerle릆irildi를nde (Animasyonsuz, direkt g칬r칲n칲m)
    else if (color !== null && prevColor.current === null) {
      blockScale.value = 1;
      blockOpacity.value = 1;
    }
    // 3. Ba륿ang캼칞 veya Reset durumu
    else if (color !== null) {
      blockScale.value = 1;
      blockOpacity.value = 1;
    }

    prevColor.current = color;
  }, [color, blockOpacity, blockScale, flashOpacity, flashScale]);

  const animatedBlockStyle = useAnimatedStyle(() => {
    return {
      // backgroundColor style prop'undan gelecek
      transform: [{ scale: blockScale.value }],
      opacity: blockOpacity.value,
    };
  });

  const animatedFlashStyle = useAnimatedStyle(() => ({
    opacity: flashOpacity.value,
    transform: [{ scale: flashScale.value }],
    backgroundColor: "white", // Flash her zaman beyaz parlama
  }));

  const displayColor = color || lastValidColor.current || "transparent";

  return (
    <View style={styles.cellContainer}>
      {/* Sabit Grid Arka Plan캼 */}
      <View style={styles.emptyGrid} />

      {/* Animasyonlu Blok veya 칐nizleme Katman캼 */}
      <Animated.View
        style={[
          styles.block,
          { backgroundColor: displayColor },
          animatedBlockStyle,
        ]}
      />

      {/* Patlama Efekti (Flash) - Sadece yok olurken g칬r칲n칲r */}
      <Animated.View
        style={[styles.flash, animatedFlashStyle]}
        pointerEvents="none"
      />
    </View>
  );
};

const styles = StyleSheet.create({
  cellContainer: {
    width: CELL_SIZE - 2,
    height: CELL_SIZE - 2,
    margin: 1,
    position: "relative",
    backgroundColor: "transparent",
  },
  emptyGrid: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255, 255, 255, 0.12)",
    borderRadius: 6, // Slightly clearer roundness
    // No border here to avoid layout calc issues, or constant border.
    // Let's use a very subtle border consistently.
    borderWidth: 1,
    borderColor: "rgba(255, 255, 255, 0.05)",
  },
  block: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 4,
  },
  flash: {
    ...StyleSheet.absoluteFillObject,
    borderRadius: 4,
    zIndex: 10,
    backgroundColor: "white",
  },
});

export default memo(Cell);
</file>

<file path="src/components/GameOverOverlay.tsx">
// src/components/GameOverOverlay.tsx
import { showInterstitial } from "@/services/adManager";
import { useAdActions } from "@/src/store/adStore";
import { useGameStore } from "@/src/store/useGameStore";
import { THEME } from "@/src/utils/constants";
import React, { useEffect, useState } from "react";
import { Image, StyleSheet, Text, TouchableOpacity, View } from "react-native";
import Animated, {
  FadeIn,
  FadeOut,
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withTiming,
} from "react-native-reanimated";

interface GameOverOverlayProps {
  onContinue: () => void;
  onReset: () => void;
}

export const GameOverOverlay = ({
  onContinue,
  onReset,
}: GameOverOverlayProps) => {
  const leaderboard = useGameStore((state) => state.leaderboard);
  const score = useGameStore((state) => state.score);
  const canContinue = score >= 500;

  // States
  const [phase, setPhase] = useState<"splash" | "menu">("splash");
  const [loadingAd, setLoadingAd] = useState(false);

  // Ad Logic
  const { canShowInterstitial, markInterstitialShown } = useAdActions();

  // Animation Values
  const shake = useSharedValue(0);

  useEffect(() => {
    // Stage 1: Show Splash for 2 seconds
    const timer = setTimeout(() => {
      setPhase("menu");
    }, 2000);

    // Trigger "Ufak bounce ile sallanma" (Small shake/bounce)
    // Sequence: Wait slightly, then small rotate shake
    shake.value = withRepeat(
      withSequence(
        withTiming(15, { duration: 100 }),
        withTiming(-15, { duration: 100 }),
        withTiming(0, { duration: 100 }),
      ),
      2, // Repeat twice
      true, // Reverse
    );

    return () => clearTimeout(timer);
  }, [shake]);

  const handleNewGame = async () => {
    if (loadingAd) return;

    // Check strict cooldown (2 mins) - passing placeholder args as we made it generic-ish
    if (canShowInterstitial(1, 1)) {
      setLoadingAd(true);
      const watched = await showInterstitial();
      if (watched) {
        markInterstitialShown();
      }
      setLoadingAd(false);
    }

    onReset();
  };

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: shake.value }], // Vertical bounce/shake
    };
  });

  // RENDER: SPLASH PHASE
  if (phase === "splash") {
    return (
      <View style={[styles.overlay, { backgroundColor: "rgba(0,0,0,0)" }]}>
        <Animated.View
          entering={FadeIn.duration(200)}
          exiting={FadeOut.duration(300)}
          style={animatedStyle}
        >
          <Image
            source={require("@/assets/images/streak/game-over.png")}
            style={styles.splashImage}
            resizeMode="contain"
          />
        </Animated.View>
      </View>
    );
  }

  // RENDER: MENU PHASE
  return (
    <Animated.View entering={FadeIn.duration(400)} style={styles.overlay}>
      <View style={styles.contentContainer}>
        <Text style={styles.title}>OYUN B캻TT캻!</Text>
        <Text style={styles.score}>{score}</Text>

        {/* Lider Tablosu */}
        <View style={styles.leaderboard}>
          <Text style={styles.lbTitle}>游끥 EN 캻Y캻LER 游끥</Text>
          {leaderboard.map((s, i) => (
            <View key={i} style={styles.lbRow}>
              <Text style={styles.lbRank}>{i + 1}.</Text>
              <Text style={styles.lbScore}>{s > 0 ? s : "---"}</Text>
            </View>
          ))}
        </View>

        <View style={styles.actions}>
          {/* Continue Section */}
          <View style={styles.continueSection}>
            <Text style={styles.description}>
              Par칞alar yenilenir ve oyun kald캼캼 yerden devam eder.
            </Text>
            <TouchableOpacity
              style={[
                styles.button,
                styles.primaryButton,
                !canContinue && styles.disabledButton,
              ]}
              onPress={canContinue ? onContinue : undefined}
              activeOpacity={canContinue ? 0.7 : 1}
            >
              <Text
                style={[styles.buttonText, !canContinue && styles.disabledText]}
              >
                DEVAM ET (-500 Puan)
              </Text>
            </TouchableOpacity>
          </View>

          <TouchableOpacity
            style={[styles.button, styles.secondaryButton]}
            onPress={handleNewGame}
            disabled={loadingAd}
          >
            <Text style={[styles.buttonText, { color: "#fff" }]}>
              {loadingAd ? "Y칖KLEN캻YOR..." : "YEN캻 OYUN BA뢻AT"}
            </Text>
          </TouchableOpacity>
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(48, 54, 79, 0.98)", // THEME.BACKGROUND with opacity
    justifyContent: "center",
    alignItems: "center",
    zIndex: 2000,
  },
  contentContainer: {
    width: "100%",
    alignItems: "center",
    paddingHorizontal: 30,
  },
  title: {
    color: THEME.TEXT_PRIMARY,
    fontSize: 42,
    fontWeight: "800",
    marginBottom: 10,
    letterSpacing: 1,
  },
  score: {
    color: THEME.TEXT_SECONDARY, // Beige instead of Cyan
    fontSize: 80,
    fontWeight: "900",
    marginBottom: 40,
    textShadowColor: "rgba(0,0,0,0.3)",
    textShadowOffset: { width: 0, height: 4 },
    textShadowRadius: 10,
  },
  leaderboard: {
    width: "100%",
    backgroundColor: THEME.SURFACE,
    borderRadius: 24,
    padding: 20,
    marginBottom: 40,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.05)",
  },
  lbTitle: {
    color: THEME.TEXT_MUTED,
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 15,
    textAlign: "center",
    letterSpacing: 2,
    marginTop: 5,
  },
  lbRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 10,
    paddingHorizontal: 10,
  },
  lbRank: { color: THEME.TEXT_MUTED, fontSize: 20, fontWeight: "600" },
  lbScore: { color: THEME.TEXT_PRIMARY, fontSize: 20, fontWeight: "700" },

  actions: { width: "100%", gap: 20 },
  continueSection: { gap: 8, width: "100%" },
  description: {
    color: THEME.TEXT_MUTED,
    fontSize: 13,
    textAlign: "center",
    fontStyle: "italic",
  },
  button: {
    padding: 20,
    borderRadius: 20,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryButton: {
    backgroundColor: THEME.SURFACE_LIGHT,
    borderWidth: 1,
    borderColor: THEME.TEXT_SECONDARY,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
  },
  secondaryButton: {
    backgroundColor: "transparent",
    borderWidth: 2,
    borderColor: THEME.SURFACE_LIGHT,
  },
  disabledButton: {
    backgroundColor: THEME.SURFACE,
    borderColor: "transparent",
    shadowOpacity: 0,
  },
  buttonText: {
    color: THEME.TEXT_PRIMARY,
    fontWeight: "800",
    fontSize: 16,
    letterSpacing: 0.5,
  },
  disabledText: { color: THEME.TEXT_MUTED },
  splashImage: {
    width: "90%",
    aspectRatio: 1,
    height: undefined,
  },
});
</file>

<file path="src/components/Piece.tsx">
// src/components/Piece.tsx
import React, { memo } from "react";
import { StyleSheet, View } from "react-native";
import { Gesture, GestureDetector } from "react-native-gesture-handler";
import Animated, {
  Easing,
  useAnimatedStyle,
  useSharedValue,
  withTiming,
} from "react-native-reanimated";
import { scheduleOnRN } from "react-native-worklets";
import { useGameStore } from "../store/useGameStore";
import { CELL_SIZE } from "../utils/constants";

const Piece = ({
  id,
  shape,
  color,
}: {
  id: string;
  shape: number[][];
  color: string;
}) => {
  const onDrop = useGameStore((state) => state.onDrop);
  const boardLayout = useGameStore((state) => state.boardLayout);
  const canPlacePiece = useGameStore((state) => state.canPlacePiece);

  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const isDragging = useSharedValue(false);
  const grabX = useSharedValue(0);
  const grabY = useSharedValue(0);

  const initialPieceScale = 0.8;
  const draggingPieceScale = 1.0;
  const FINGER_OFFSET_Y = -60; // Par칞a parma캼n 칲st칲nde g칬r칲ns칲n

  const gesture = Gesture.Pan()
    .runOnJS(true)
    .onStart((e) => {
      isDragging.value = true;
      grabX.value = e.x;
      grabY.value = e.y;
    })
    .onUpdate((e) => {
      translateX.value = e.translationX;
      translateY.value = e.translationY + FINGER_OFFSET_Y;
    })
    .onEnd((e) => {
      isDragging.value = false;

      let placed = false;
      if (boardLayout) {
        // Board ba륿ang캼칞 noktas캼 (padding dahil)
        const boardOriginX = boardLayout.x + 2;
        const boardOriginY = boardLayout.y + 2;

        // Par칞an캼n sol 칲st k칬른sinin anl캼k ekran konumu
        const pieceScreenX = e.absoluteX - grabX.value;
        const pieceScreenY = e.absoluteY - grabY.value + FINGER_OFFSET_Y;

        // Par칞an캼n grid 칲zerindeki "kesirli" (float) ba륿ang캼칞 indeksi
        // 칐rn: 3.6 sat캼r, 4.2 s칲tun gibi
        const floatCol = (pieceScreenX - boardOriginX) / CELL_SIZE;
        const floatRow = (pieceScreenY - boardOriginY) / CELL_SIZE;

        // ALAN BAZLI SNAP MANTI뢸:
        // Par칞an캼n olas캼 "hedef" h칲crelerini belirlemek i칞in en yak캼n tam say캼lar캼 al캼yoruz.
        // Ancak sadece Math.round yetmez, bir "b칲t칲n" olarak en iyi oturdu릇 yeri bulmal캼y캼z.

        // Adaylar: En yak캼n tam say캼 ve etraf캼
        const candidates = [
          { r: Math.round(floatRow), c: Math.round(floatCol) }, // En yak캼n (Merkez)
          { r: Math.floor(floatRow), c: Math.floor(floatCol) }, // Sol 칖st
          { r: Math.ceil(floatRow), c: Math.ceil(floatCol) }, // Sa Alt
          { r: Math.floor(floatRow), c: Math.ceil(floatCol) }, // Sa 칖st
          { r: Math.ceil(floatRow), c: Math.floor(floatCol) }, // Sol Alt
        ];

        // M칲kerrer adaylar캼 temizle
        const uniqueCandidates = candidates.filter(
          (v, i, a) => a.findIndex((t) => t.r === v.r && t.c === v.c) === i,
        );

        let bestCandidate = null;
        let maxOverlap = -1;

        // Her aday캼 test et: "E른r par칞ay캼 buraya koyarsam, elimdeki par칞a ile hedef ne kadar 칬rt칲칲yor?"
        // Asl캼nda burada "overlap" (칬rt칲릀e) hesab캼 yap캼yoruz.
        // Kullan캼c캼n캼n b캼rakt캼캼 "float" konum ile, aday캼n "tam say캼" konumu aras캼ndaki mesafe ne kadar azsa,
        // 칬rt칲릀e o kadar fazlad캼r.

        for (const cand of uniqueCandidates) {
          if (canPlacePiece(shape, cand.r, cand.c)) {
            // 칐klid mesafesi yerine "Overlap Alan캼" mant캼캼na benzer bir puanlama:
            // 1 - Uzakl캼k. (Uzakl캼k 0 ise puan 1 tam puan)

            const distR = Math.abs(cand.r - floatRow);
            const distC = Math.abs(cand.c - floatCol);

            // Basit bir "yak캼nl캼k puan캼" (Ters mesafe)
            // Mesafelerin karesini alarak uzak olanlar캼 daha 칞ok cezaland캼r캼yoruz.
            const score = 1 - (distR * distR + distC * distC);

            if (score > maxOverlap) {
              maxOverlap = score;
              bestCandidate = cand;
            }
          }
        }

        // E른r ge칞erli bir aday bulunduysa ve belli bir mant캼k dahilindeyse
        if (bestCandidate) {
          const { r, c } = bestCandidate;

          const snapX = c * CELL_SIZE + boardOriginX;
          const snapY = r * CELL_SIZE + boardOriginY;

          // G칬rsel kayd캼rma
          const currentAbsX = pieceScreenX;
          const currentAbsY = pieceScreenY;

          const targetTranslateX = e.translationX + (snapX - currentAbsX);
          const targetTranslateY = e.translationY + (snapY - currentAbsY);

          translateX.value = withTiming(targetTranslateX, { duration: 50 });
          translateY.value = withTiming(targetTranslateY, { duration: 50 });

          scheduleOnRN(onDrop, id, shape, r, c, color);
          placed = true;
        }
      }

      if (!placed) {
        // Yerle릀ediyse geri g칬nder
        translateX.value = withTiming(0, {
          duration: 250,
          easing: Easing.out(Easing.back(1.5)),
        });
        translateY.value = withTiming(0, {
          duration: 250,
          easing: Easing.out(Easing.back(1.5)),
        });
      }
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      {
        scale: withTiming(
          isDragging.value ? draggingPieceScale : initialPieceScale,
          {
            duration: 150,
          },
        ),
      },
    ],
    zIndex: isDragging.value ? 1000 : 1,
    opacity: withTiming(isDragging.value ? 0.9 : 1, { duration: 150 }),
  }));

  return (
    <GestureDetector gesture={gesture}>
      <Animated.View style={animatedStyle}>
        {shape.map((r, ri) => (
          <View key={ri} style={{ flexDirection: "row" }}>
            {r.map((c, ci) => (
              <View
                key={ci}
                style={[
                  styles.cell,
                  {
                    backgroundColor: c ? color : "transparent",
                    opacity: c ? 1 : 0,
                  },
                ]}
              />
            ))}
          </View>
        ))}
      </Animated.View>
    </GestureDetector>
  );
};

const styles = StyleSheet.create({
  cell: {
    width: CELL_SIZE - 2,
    height: CELL_SIZE - 2,
    margin: 1,
    borderRadius: 4,
    borderWidth: 0.5,
    borderColor: "rgba(255,255,255,0.1)",
  },
});

export default memo(Piece);
</file>

<file path="src/components/PuffExplosion.tsx">
import React, { memo, useEffect, useMemo } from "react";
import { StyleSheet, View } from "react-native";
import Animated, {
  Easing,
  interpolate,
  useAnimatedStyle,
  useSharedValue,
  withTiming,
} from "react-native-reanimated";

interface PuffExplosionProps {
  color: string;
  onComplete: () => void;
}

const PARTICLE_COUNT = 8;
const EXPLOSION_OFFSET = 30;

// Optimize by running one single animation for the whole container
const PuffExplosionComponent = ({ color, onComplete }: PuffExplosionProps) => {
  const progress = useSharedValue(0);

  // Pre-calculate random properties for particles so they are static during renders
  const particlesConfig = useMemo(() => {
    return Array.from({ length: PARTICLE_COUNT }).map((_, i) => {
      const angle = (360 / PARTICLE_COUNT) * i;
      // Slight randomness for "organic" feel
      const extraDist = Math.random() * 10;
      // Delay simulated by start range in interpolation
      const startDelay = Math.random() * 0.2;

      return {
        key: i,
        angle: (angle * Math.PI) / 180, // Convert to radians
        rotation: angle,
        extraDist,
        startDelay,
      };
    });
  }, []);

  useEffect(() => {
    // Single driver for all particles
    progress.value = withTiming(1, {
      duration: 500,
      easing: Easing.out(Easing.quad),
    });
    // Fallback safety to ensure cleanup happens
    const t = setTimeout(onComplete, 550);
    return () => clearTimeout(t);
  }, [onComplete, progress]);

  // Shockwave Style
  const shockwaveStyle = useAnimatedStyle(() => {
    return {
      transform: [{ scale: interpolate(progress.value, [0, 1], [0.5, 2]) }],
      opacity: interpolate(progress.value, [0, 0.5, 1], [0.8, 0.5, 0]),
      borderColor: color,
    };
  });

  return (
    <View style={styles.container} pointerEvents="none">
      {/* Single Shockwave */}
      <Animated.View style={[styles.shockwave, shockwaveStyle]} />

      {/* Particles mapped directly here to avoid sub-component overhead */}
      {particlesConfig.map((p) => {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const pStyle = useAnimatedStyle(() => {
          // Map global progress to local particle progress based on startDelay
          // 0 -> startDelay -> 1
          // If progress < startDelay, localP = 0
          const localProgress = interpolate(
            progress.value,
            [p.startDelay, 1],
            [0, 1],
            "clamp",
          );

          const dist = EXPLOSION_OFFSET + p.extraDist;
          const x = localProgress * dist * Math.cos(p.angle);
          const y = localProgress * dist * Math.sin(p.angle);

          const scale = interpolate(localProgress, [0, 0.7], [1, 0], "clamp");

          return {
            opacity: 1 - localProgress,
            transform: [
              { translateX: x },
              { translateY: y },
              { scale },
              { rotate: `${p.rotation}deg` },
            ],
            backgroundColor: color,
          };
        });

        return <Animated.View key={p.key} style={[styles.particle, pStyle]} />;
      })}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
    zIndex: 10,
  },
  particle: {
    width: 6,
    height: 6,
    position: "absolute",
    borderRadius: 2,
  },
  shockwave: {
    position: "absolute",
    width: "80%",
    height: "80%",
    borderWidth: 2,
    borderRadius: 4,
  },
});

export const PuffExplosion = memo(PuffExplosionComponent);
</file>

<file path="src/components/ScoreBoard.tsx">
// src/components/ScoreBoard.tsx
import React from "react";
import { StyleSheet, Text, View } from "react-native";
import { useGameStore } from "../store/useGameStore";
import { THEME } from "../utils/constants";

export const ScoreBoard = () => {
  const score = useGameStore((state) => state.score);
  const streak = useGameStore((state) => state.streak);

  return (
    <View style={styles.container}>
      <View style={styles.statBox}>
        <Text style={styles.label}>SCORE</Text>
        <Text style={styles.value}>{score}</Text>
      </View>

      <View style={styles.divider} />

      <View style={styles.statBox}>
        <Text style={[styles.label, { color: THEME.TEXT_SECONDARY }]}>
          STREAK
        </Text>
        <Text style={[styles.value, { color: THEME.TEXT_SECONDARY }]}>
          x{streak || 0}
        </Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: THEME.SURFACE,
    borderRadius: 16,
    padding: 8,
    paddingHorizontal: 24, // Slightly wider for better look
    gap: 20,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.05)",
  },
  statBox: {
    alignItems: "center", // Center align text inside box for symmetry
  },
  divider: {
    width: 1,
    height: 24,
    backgroundColor: THEME.TEXT_MUTED,
    opacity: 0.2,
  },
  label: {
    color: THEME.TEXT_MUTED,
    fontSize: 10,
    fontWeight: "bold",
    marginBottom: 2,
    textAlign: "center",
  },
  value: {
    color: THEME.TEXT_PRIMARY,
    fontSize: 20,
    fontWeight: "900",
    textAlign: "center",
  },
});
</file>

<file path="src/components/Splash/CustomSplashScreen.tsx">
import { initializeAds } from "@/services/adManager";
import React, { useEffect } from "react";
import { Dimensions, Image, StyleSheet, Text, View } from "react-native";
import Animated, {
  Easing,
  runOnJS,
  useAnimatedStyle,
  useSharedValue,
  withTiming,
} from "react-native-reanimated";

interface CustomSplashScreenProps {
  onFinish: () => void;
}

const { width } = Dimensions.get("window");
const LOGO_SIZE = width * 0.4;
const BAR_WIDTH = width * 0.7;
const BAR_HEIGHT = 8;

export const CustomSplashScreen = ({ onFinish }: CustomSplashScreenProps) => {
  const progress = useSharedValue(0);
  const opacity = useSharedValue(1);
  const logoScale = useSharedValue(0.8);

  useEffect(() => {
    // 1. Initialize Ads and other background tasks
    initializeAds();

    // 2. Start Animations
    logoScale.value = withTiming(1, {
      duration: 800,
      easing: Easing.out(Easing.back(1.5)),
    });

    progress.value = withTiming(
      1,
      { duration: 2500, easing: Easing.inOut(Easing.quad) },
      (finished) => {
        if (finished) {
          // Fade out everything
          opacity.value = withTiming(0, { duration: 500 }, (faded) => {
            if (faded) {
              runOnJS(onFinish)();
            }
          });
        }
      },
    );
  }, []);

  const animatedContainerStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
  }));

  const animatedLogoStyle = useAnimatedStyle(() => ({
    transform: [{ scale: logoScale.value }],
  }));

  const animatedProgressStyle = useAnimatedStyle(() => ({
    width: progress.value * BAR_WIDTH,
  }));

  return (
    <Animated.View style={[styles.container, animatedContainerStyle]}>
      <Animated.View style={animatedLogoStyle}>
        <Image
          source={require("@/assets/images/icon.png")}
          style={styles.logo}
          resizeMode="contain"
        />
      </Animated.View>

      <Text style={styles.title}>GRID GRIN</Text>

      <View style={styles.progressContainer}>
        <Animated.View style={[styles.progressBar, animatedProgressStyle]} />
      </View>

      <Text style={styles.loadingText}>Y칲kleniyor...</Text>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "#121214", // Dark theme background
    justifyContent: "center",
    alignItems: "center",
    zIndex: 9999,
  },
  logo: {
    width: LOGO_SIZE,
    height: LOGO_SIZE,
    marginBottom: 20,
  },
  title: {
    fontSize: 32,
    fontWeight: "900",
    color: "#fff",
    marginBottom: 50,
    letterSpacing: 2,
  },
  progressContainer: {
    width: BAR_WIDTH,
    height: BAR_HEIGHT,
    backgroundColor: "rgba(255,255,255,0.1)",
    borderRadius: BAR_HEIGHT / 2,
    overflow: "hidden",
    marginBottom: 15,
  },
  progressBar: {
    height: "100%",
    backgroundColor: "#00E0FF", // Neon Cyan
    borderRadius: BAR_HEIGHT / 2,
  },
  loadingText: {
    color: "#666",
    fontSize: 12,
    letterSpacing: 1,
    textTransform: "uppercase",
  },
});
</file>

<file path="src/components/StreakOverlay.tsx">
import { Image } from "expo-image";
import React, { useEffect, useState } from "react";
import { StyleSheet, View } from "react-native";
import Animated, {
  runOnJS,
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  withTiming,
} from "react-native-reanimated";
import { useGameStore } from "../store/useGameStore";

// Streak g칬rselleri
const STREAK_IMAGES = {
  good: require("../../assets/images/streak/good.png"),
  sweet: require("../../assets/images/streak/sweet.png"),
  perfect: require("../../assets/images/streak/perfect.png"),
  perfect_streak: require("../../assets/images/streak/perfect-streak.png"),
};

export const StreakOverlay = () => {
  const streak = useGameStore((state) => state.streak);
  const milestoneEvent = useGameStore((state) => state.milestoneEvent);
  const clearMilestone = useGameStore((state) => state.clearMilestone);
  const [activeImage, setActiveImage] = useState<any>(null);

  const scale = useSharedValue(0);
  const translateY = useSharedValue(50);
  const opacity = useSharedValue(0);

  useEffect(() => {
    let img = null;

    // 1. Milestone 칐ncelikli (Rekor)
    if (milestoneEvent) {
      if (milestoneEvent === "sweet") img = STREAK_IMAGES.sweet;
      else if (milestoneEvent === "good") img = STREAK_IMAGES.good;
      else if (milestoneEvent === "perfect") img = STREAK_IMAGES.perfect;

      clearMilestone(); // Event'i resetle
    }
    // 2. Normal Streak
    else if (streak >= 2) {
      if (streak >= 10) img = STREAK_IMAGES.perfect_streak;
      else if (streak >= 7) img = STREAK_IMAGES.perfect;
      else if (streak >= 4) img = STREAK_IMAGES.sweet;
      else if (streak >= 2) img = STREAK_IMAGES.good;
    }

    if (img) {
      setActiveImage(img);
      scale.value = 0;
      translateY.value = 50;
      opacity.value = 1;

      scale.value = withSpring(1);
      translateY.value = withSpring(0);

      // 1.5 saniye sonra kaybol
      setTimeout(() => {
        opacity.value = withTiming(0, { duration: 300 }, () => {
          runOnJS(setActiveImage)(null);
        });
      }, 1500);
    }
  }, [
    streak,
    milestoneEvent,
    activeImage,
    clearMilestone,
    opacity,
    scale,
    translateY,
  ]);

  const style = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }, { translateY: translateY.value }],
    opacity: opacity.value,
  }));

  if (!activeImage) return null;

  return (
    <View style={styles.container} pointerEvents="none">
      <Animated.View style={style}>
        <Image source={activeImage} style={styles.image} contentFit="contain" />
      </Animated.View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
    zIndex: 100,
    marginTop: -100, // Board'un biraz 칲zerinde olsun
  },
  image: {
    width: 300,
    height: 150,
  },
});
</file>

<file path="src/store/adStore.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { create } from "zustand";

// ==========================================
// AD CONFIGURATION
// ==========================================

export const AD_RULES = {
  // Interstitial rules
  interstitial: {
    excludedLevels: [], // No exclusions for infinite mode
    minTimeBetweenAds: 120000, // 2 minutes between interstitial ads
    showOnLevelEntry: false,
  },

  // Rewarded rules
  rewarded: {
    enabled: true, // Rewarded ads for hints
  },

  // Banner rules
  banner: {
    showInGame: true, // Show banner at top of game screen
    showInChapters: false, // Don't show banner in chapters (use native ads instead)
  },

  // Native ads rules
  native: {
    showInChapters: true, // Show native ad in chapters screen
    showEveryNChapters: 4, // Show ad after every 4 chapters
  },
};

// ==========================================
// AD STATE INTERFACE
// ==========================================

interface AdState {
  // Last shown timestamps
  lastInterstitialShown: number;
  lastRewardedShown: number;

  // Ad readiness
  isInterstitialReady: boolean;
  isRewardedReady: boolean;
  isBannerReady: boolean;

  // Statistics
  totalInterstitialsShown: number;
  totalRewardedsShown: number;
  totalBannersShown: number;

  // Global ad state
  isAdShowing: boolean; // True when a full-screen ad (Interstitial/Rewarded) is open
}

interface AdActions {
  // Interstitial
  canShowInterstitial: (chapterId: number, levelId: number) => boolean;
  markInterstitialShown: () => void;
  setInterstitialReady: (ready: boolean) => void;

  // Rewarded
  canShowRewarded: () => boolean;
  markRewardedShown: () => void;
  setRewardedReady: (ready: boolean) => void;

  // Banner
  canShowBanner: () => boolean;
  setBannerReady: (ready: boolean) => void;

  // Native
  shouldShowNativeAdAtIndex: (index: number) => boolean;

  // Persistence
  loadAdState: () => Promise<void>;
  saveAdState: () => Promise<void>;

  // Global state
  setAdShowing: (showing: boolean) => void;
}

interface AdStore extends AdState {
  actions: AdActions;
}

// ==========================================
// STORAGE KEY
// ==========================================

const AD_STATE_KEY = "@puzzle_game_ad_state";

// ==========================================
// INITIAL STATE
// ==========================================

const initialState: AdState = {
  lastInterstitialShown: 0,
  lastRewardedShown: 0,
  isInterstitialReady: false,
  isRewardedReady: false,
  isBannerReady: false,
  totalInterstitialsShown: 0,
  totalRewardedsShown: 0,
  totalBannersShown: 0,
  isAdShowing: false,
};

// ==========================================
// AD STORE
// ==========================================

export const useAdStore = create<AdStore>((set, get) => ({
  ...initialState,

  actions: {
    // ==========================================
    // INTERSTITIAL ADS
    // ==========================================

    canShowInterstitial: (chapterId: number, levelId: number) => {
      const state = get();

      // Check if this level is excluded
      const isExcluded = AD_RULES.interstitial.excludedLevels.some(
        (excluded) =>
          excluded.chapterId === chapterId && excluded.levelId === levelId,
      );

      if (isExcluded) {
        console.log(`游닠 Level ${chapterId}-${levelId} is excluded from ads`);
        return false;
      }

      // Check if enough time has passed
      const now = Date.now();
      const timeSinceLastAd = now - state.lastInterstitialShown;
      if (timeSinceLastAd < AD_RULES.interstitial.minTimeBetweenAds) {
        const remainingSeconds = Math.ceil(
          (AD_RULES.interstitial.minTimeBetweenAds - timeSinceLastAd) / 1000,
        );
        console.log(`游닠 Too soon for ad, wait ${remainingSeconds}s`);
        return false;
      }

      // Check if ad is ready
      if (!state.isInterstitialReady) {
        console.log("游닠 Interstitial not ready");
        return false;
      }

      return true;
    },

    markInterstitialShown: () => {
      const now = Date.now();
      set((state) => ({
        lastInterstitialShown: now,
        totalInterstitialsShown: state.totalInterstitialsShown + 1,
        isInterstitialReady: false, // Will be reloaded
      }));
      get().actions.saveAdState();
    },

    setInterstitialReady: (ready: boolean) => {
      set({ isInterstitialReady: ready });
    },

    // ==========================================
    // REWARDED ADS
    // ==========================================

    canShowRewarded: () => {
      const state = get();

      if (!AD_RULES.rewarded.enabled) {
        console.log("游꾸 Rewarded ads disabled");
        return false;
      }

      if (!state.isRewardedReady) {
        console.log("游꾸 Rewarded not ready");
        return false;
      }

      return true;
    },

    markRewardedShown: () => {
      const now = Date.now();
      set((state) => ({
        lastRewardedShown: now,
        totalRewardedsShown: state.totalRewardedsShown + 1,
        isRewardedReady: false, // Will be reloaded
      }));
      get().actions.saveAdState();
    },

    setRewardedReady: (ready: boolean) => {
      set({ isRewardedReady: ready });
    },

    // ==========================================
    // BANNER ADS
    // ==========================================

    canShowBanner: () => {
      const state = get();
      return AD_RULES.banner.showInGame && state.isBannerReady;
    },

    setBannerReady: (ready: boolean) => {
      set({ isBannerReady: ready });
    },

    // ==========================================
    // NATIVE ADS
    // ==========================================

    shouldShowNativeAdAtIndex: (index: number) => {
      if (!AD_RULES.native.showInChapters) return false;

      // Show ad every N chapters (e.g., after chapter 4, 8, 12, etc.)
      // Index is 0-based, so we add 1
      const chapterNumber = index + 1;
      return chapterNumber % AD_RULES.native.showEveryNChapters === 0;
    },

    // ==========================================
    // PERSISTENCE
    // ==========================================

    loadAdState: async () => {
      try {
        const stored = await AsyncStorage.getItem(AD_STATE_KEY);
        if (stored) {
          const parsed = JSON.parse(stored);
          set({
            lastInterstitialShown: parsed.lastInterstitialShown || 0,
            lastRewardedShown: parsed.lastRewardedShown || 0,
            totalInterstitialsShown: parsed.totalInterstitialsShown || 0,
            totalRewardedsShown: parsed.totalRewardedsShown || 0,
            totalBannersShown: parsed.totalBannersShown || 0,
          });
          console.log("游닠 Ad state loaded from storage");
        }
      } catch (error) {
        console.error("游닠 Failed to load ad state:", error);
      }
    },

    saveAdState: async () => {
      try {
        const state = get();
        const toSave = {
          lastInterstitialShown: state.lastInterstitialShown,
          lastRewardedShown: state.lastRewardedShown,
          totalInterstitialsShown: state.totalInterstitialsShown,
          totalRewardedsShown: state.totalRewardedsShown,
          totalBannersShown: state.totalBannersShown,
        };
        await AsyncStorage.setItem(AD_STATE_KEY, JSON.stringify(toSave));
      } catch (error) {
        console.error("游닠 Failed to save ad state:", error);
      }
    },

    setAdShowing: (showing: boolean) => {
      set({ isAdShowing: showing });
    },
  },
}));

// ==========================================
// HOOKS
// ==========================================

export const useAdActions = () => useAdStore((state) => state.actions);
export const useIsInterstitialReady = () =>
  useAdStore((state) => state.isInterstitialReady);
export const useIsRewardedReady = () =>
  useAdStore((state) => state.isRewardedReady);
export const useIsBannerReady = () =>
  useAdStore((state) => state.isBannerReady);
export const useIsAdShowing = () => useAdStore((state) => state.isAdShowing);
</file>

<file path="src/store/useGameStore.ts">
// src/store/useGameStore.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import * as Haptics from "expo-haptics";
import { create } from "zustand";
import { BOARD_SIZE, SCORING, SHAPES } from "../utils/constants";
import { processMove } from "../utils/gameLogic";

interface GameState {
  board: (string | null)[][];
  score: number;
  streak: number;
  lastMoveResult: any | null;
  lastSavedScore: number | null; // Oturum takibi i칞in
  availablePieces: { id: string; shape: number[][]; color: string }[];
  boardLayout: { x: number; y: number; size: number } | null;
  setBoardLayout: (layout: { x: number; y: number; size: number }) => void;
  bestScore: number;
  leaderboard: number[]; // Top 3 Scores
  milestoneEvent: "sweet" | "good" | "perfect" | null; // For UI feedback
  isGameOver: boolean;
  hasSavedGame: boolean;
  loadLeaderboard: () => Promise<void>;

  // Persistence
  saveGame: () => Promise<void>;
  loadGame: () => Promise<void>;

  resetGame: () => void;
  checkGameOver: () => void;
  continueWithNewPieces: () => void;

  refreshPieces: (checkPlayability?: boolean) => void;
  removePiece: (id: string) => void;
  onDrop: (
    id: string,
    shape: number[][],
    row: number,
    col: number,
    color: string,
  ) => void;
  handleMove: (piece: number[][], r: number, c: number, color: string) => void;
  canPlacePiece: (piece: number[][], row: number, col: number) => boolean;
  clearMilestone: () => void;
}

export const useGameStore = create<GameState>((set, get) => ({
  board: Array(BOARD_SIZE)
    .fill(null)
    .map(() => Array(BOARD_SIZE).fill(null)),
  score: 0,
  streak: 0,
  lastMoveResult: null,
  lastSavedScore: null,
  availablePieces: [],
  boardLayout: null,
  setBoardLayout: (layout) => set({ boardLayout: layout }),
  bestScore: 0,
  leaderboard: [0, 0, 0],
  milestoneEvent: null,
  isGameOver: false,
  hasSavedGame: false,

  saveGame: async () => {
    const { board, score, streak, availablePieces, isGameOver } = get();
    // Don't save if game over
    if (isGameOver) {
      await AsyncStorage.removeItem("gameState");
      set({ hasSavedGame: false });
      return;
    }

    const stateToSave = {
      board,
      score,
      streak,
      availablePieces,
    };
    try {
      await AsyncStorage.setItem("gameState", JSON.stringify(stateToSave));
      set({ hasSavedGame: true });
    } catch (e) {
      console.error("Failed to save game", e);
    }
  },

  loadGame: async () => {
    try {
      const stored = await AsyncStorage.getItem("gameState");
      const savedLeaderboard = await AsyncStorage.getItem("leaderboard");

      if (savedLeaderboard) {
        set({ leaderboard: JSON.parse(savedLeaderboard) });
      }

      if (stored) {
        const parsed = JSON.parse(stored);
        set({
          board: parsed.board,
          score: parsed.score,
          streak: parsed.streak,
          availablePieces: parsed.availablePieces,
          hasSavedGame: true,
          isGameOver: false,
        });
      } else {
        set({ hasSavedGame: false });
      }
    } catch (e) {
      console.error("Failed to load game", e);
    }
  },

  loadLeaderboard: async () => {
    try {
      const stored = await AsyncStorage.getItem("leaderboard");
      if (stored) {
        set({ leaderboard: JSON.parse(stored) });
      }
    } catch (e) {
      console.error("Failed to load leaderboard", e);
    }
  },

  handleMove: (piece, r, c, color) => {
    const { board, streak, score: currentScore, leaderboard } = get();
    // 1. Hamleyi i륿e (Puan hesab캼 hari칞)
    const result = processMove(board, piece, r, c, color, streak);

    const clearedCount = result.clearedRows.length + result.clearedCols.length;
    let moveScore = 0;
    let newStreak = 0;

    // 2. Puanlama Mant캼캼 (User Rules)
    if (clearedCount > 0) {
      // Temel Puan
      if (clearedCount === 1) {
        moveScore = SCORING.SINGLE_LINE;
      } else {
        // (S캼ra x 100) + (S캼ra x 25)
        moveScore =
          clearedCount * SCORING.MULTI_LINE_BASE +
          clearedCount * SCORING.MULTI_LINE_BONUS;
      }

      // Streak Artt캼r
      newStreak = streak + 1;

      // Streak Bonusu (Streak >= 2 ise)
      if (newStreak >= 2) {
        moveScore += Math.floor(
          moveScore * SCORING.STREAK_MULTIPLIER * newStreak,
        );
      }
    } else {
      // Hi칞bir 른y silinmediyse streak s캼f캼rlan캼r
      newStreak = 0;
    }

    const newTotalScore = currentScore + moveScore;

    let milestone: GameState["milestoneEvent"] = null;
    const [first, second, third] = leaderboard;

    // Skor de를를mi s캼n캼rlar캼 ge칞ti mi?
    if (currentScore < third && newTotalScore >= third && third > 0)
      milestone = "sweet";
    else if (currentScore < second && newTotalScore >= second && second > 0)
      milestone = "good";
    else if (currentScore < first && newTotalScore >= first && first > 0)
      milestone = "perfect";

    set({
      board: result.placedBoard,
      score: newTotalScore,
      streak: newStreak,
      milestoneEvent: milestone,
    });

    if (clearedCount > 0) {
      setTimeout(() => {
        set({ board: result.newBoard });
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
        // Board temizlendikten sonra Game Over kontrol칲 yap
        get().checkGameOver();
      }, 50);
    } else {
      set({ board: result.newBoard });
      Haptics.selectionAsync();
      // Hemen Game Over kontrol칲 yap
      get().checkGameOver();
    }
  },

  clearMilestone: () => set({ milestoneEvent: null }),

  refreshPieces: (checkPlayability = false) => {
    const colors = [
      "#FF5733", // Red-Orange
      "#33FF57", // Green
      "#3357FF", // Blue
      "#F333FF", // Pink/Purple
      "#FFC300", // Gold/Yellow
      "#00F5FF", // Cyan
      "#FF33A1", // Hot Pink
    ];
    const shapesKeys = Object.keys(SHAPES) as (keyof typeof SHAPES)[];

    const doesPieceFit = (
      piece: number[][],
      currentBoard: (string | null)[][],
    ) => {
      const boardSize = currentBoard.length;
      for (let r = 0; r <= boardSize - piece.length; r++) {
        // D캻KKAT: Burada da ayn캼 hata olmas캼n diye <= yapt캼k (zaten doruydu ama emin olal캼m)
        for (let c = 0; c <= boardSize - piece[0].length; c++) {
          let fits = true;
          for (let pr = 0; pr < piece.length; pr++) {
            for (let pc = 0; pc < piece[pr].length; pc++) {
              if (
                piece[pr][pc] === 1 &&
                currentBoard[r + pr][c + pc] !== null
              ) {
                fits = false;
                break;
              }
            }
            if (!fits) break;
          }
          if (fits) return true;
        }
      }
      return false;
    };

    const newPieces = [1, 2, 3].map(() => ({
      id: Math.random().toString(36),
      shape: SHAPES[shapesKeys[Math.floor(Math.random() * shapesKeys.length)]],
      color: colors[Math.floor(Math.random() * colors.length)],
    }));

    if (checkPlayability) {
      const { board } = get();
      const isAnyPlayable = newPieces.some((p) => doesPieceFit(p.shape, board));
      if (!isAnyPlayable) {
        // En g칲venli par칞a ile de를릆ir
        newPieces[0] = {
          id: Math.random().toString(36) + "_safe",
          shape: SHAPES.DOT,
          color: colors[0],
        };
      }
    }

    set({ availablePieces: newPieces });
  },

  removePiece: (id) => {
    const nextPieces = get().availablePieces.filter((p) => p.id !== id);
    set({ availablePieces: nextPieces });
    if (nextPieces.length === 0) {
      get().refreshPieces();
    }
  },

  canPlacePiece: (piece, row, col) => {
    const { board } = get();
    const boardSize = board.length;
    for (let r = 0; r < piece.length; r++) {
      for (let c = 0; c < piece[r].length; c++) {
        if (piece[r][c] === 1) {
          const targetR = row + r;
          const targetC = col + c;
          if (
            targetR < 0 ||
            targetR >= boardSize ||
            targetC < 0 ||
            targetC >= boardSize ||
            board[targetR][targetC] !== null
          )
            return false;
        }
      }
    }
    return true;
  },

  onDrop: (id, shape, row, col, color) => {
    const { canPlacePiece, handleMove, removePiece } = get();
    if (canPlacePiece(shape, row, col)) {
      // 칐NCE par칞ay캼 elden 칞캼kar
      removePiece(id);
      // SONRA hamleyi i륿e
      handleMove(shape, row, col, color);
    }
  },

  checkGameOver: () => {
    const { availablePieces, canPlacePiece, isGameOver } = get();
    // Oyun zaten bitmi릅e tekrar bakma
    if (isGameOver || availablePieces.length === 0) return;

    const canMove = availablePieces.some((piece) => {
      // --- D칖ZELTME BURADA YAPILDI ---
      // Sat캼r kontrol칲
      for (let r = 0; r <= BOARD_SIZE - piece.shape.length; r++) {
        // S칲tun kontrol칲: Eskiden < (k칲칞칲kt칲r) idi, 를mdi <= (k칲칞칲k e를ttir) yapt캼k.
        // Bu sayede son s칲tunu da kontrol ediyor.
        for (let c = 0; c <= BOARD_SIZE - piece.shape[0].length; c++) {
          if (canPlacePiece(piece.shape, r, c)) return true;
        }
      }
      return false;
    });

    if (!canMove) {
      const { score, leaderboard, lastSavedScore } = get();

      let newLeaderboard = [...leaderboard];
      let shouldUpdate = false;

      // E른r bu "Continue" sonras캼 bir Game Over ise:
      if (lastSavedScore !== null) {
        if (score > lastSavedScore) {
          const indexToRemove = newLeaderboard.indexOf(lastSavedScore);
          if (indexToRemove !== -1) {
            newLeaderboard.splice(indexToRemove, 1);
          }
          newLeaderboard.push(score);
          shouldUpdate = true;
        }
      } else {
        // 캻lk Game Over
        newLeaderboard.push(score);
        shouldUpdate = true;
      }

      if (shouldUpdate) {
        newLeaderboard.sort((a, b) => b - a);
        newLeaderboard = newLeaderboard.slice(0, 3);

        AsyncStorage.setItem("leaderboard", JSON.stringify(newLeaderboard));
        set({
          leaderboard: newLeaderboard,
          bestScore: newLeaderboard[0],
        });
      }

      const sessionBest =
        lastSavedScore !== null ? Math.max(score, lastSavedScore) : score;

      set({
        isGameOver: true,
        lastSavedScore: sessionBest,
      });
    }
  },

  resetGame: () => {
    set({
      board: Array(BOARD_SIZE)
        .fill(null)
        .map(() => Array(BOARD_SIZE).fill(null)),
      score: 0,
      streak: 0,
      isGameOver: false,
      lastMoveResult: null,
      milestoneEvent: null,
      lastSavedScore: null,
    });
    get().refreshPieces();
  },

  continueWithNewPieces: () => {
    const { score } = get();
    if (score >= 500) {
      set({
        isGameOver: false,
        score: score - 500,
      });
      get().refreshPieces(true);
    }
  },
}));
</file>

<file path="src/types/index.ts">
// src/types/index.ts
export type PieceType = number[][];

export interface GameCell {
  row: number;
  col: number;
  color: string | null;
}
</file>

<file path="src/utils/constants.ts">
// src/utils/constants.ts
import { Dimensions } from "react-native";
const { width, height } = Dimensions.get("window");
export const BOARD_SIZE = 9;

export const SHAPES = {
  DOT: [[1]],
  SQUARE_2x2: [
    [1, 1],
    [1, 1],
  ],
  SQUARE_3x3: [
    [1, 1, 1],
    [1, 1, 1],
    [1, 1, 1],
  ],
  LINE_3_H: [[1, 1, 1]],
  LINE_3_V: [[1], [1], [1]],
  L_SHAPE: [
    [1, 0],
    [1, 0],
    [1, 1],
  ],
  L_SHAPE_2: [
    [0, 1],
    [0, 1],
    [1, 1],
  ],
  Z_SHAPE: [
    [1, 1, 0],
    [0, 1, 1],
  ],
  Z_SHAPE_2: [
    [0, 1, 1],
    [1, 1, 0],
  ],
  T_SHAPE: [
    [1, 1, 1],
    [0, 1, 0],
  ],
  T_REVERSED: [
    [0, 1, 0],
    [1, 1, 1],
  ],
  T_LEFT: [
    [1, 0],
    [1, 1],
    [1, 0],
  ],
  T_RIGHT: [
    [0, 1],
    [1, 1],
    [0, 1],
  ],
  R_LEFT: [
    [1, 0],
    [1, 1],
    [1, 1],
  ],
  R_RIGHT: [
    [0, 1],
    [1, 1],
    [0, 1],
  ],
};

export const THEME = {
  // User Palette
  // 30364F - Main Dark Blue
  // ACBAC4 - Muted Blue/Grey
  // E1D9BC - Beige/Sand
  // F0F0DB - Lightest Beige

  BACKGROUND: "#25343F", // Main Background
  SURFACE: "#23293B", // Slightly darker for clear contrast or "#3B4461" for lighter. Let's go darker for depth.
  SURFACE_LIGHT: "#434C68", // Lighter surface for interaction

  TEXT_PRIMARY: "#F0F0DB", // Lightest
  TEXT_SECONDARY: "#FF5FCF", // Beige
  TEXT_MUTED: "#ACBAC4", // Greyish

  ACCENT: "#E1D9BC", // Using the beige as accent for now, or maybe a generated vibrant one?
  // Let's keep Vibrant colors for game pieces separately?

  // Specific UI
  BUTTON_BG: "#434C68",
  BUTTON_TEXT: "#FFFFFF",
  BUTTON_PRIMARY: "#FF5FCF",
  BUTTON_SECONDARY: "#ACBAC4",
};

export const SCORING = {
  BASE_CELL: 0, // H칲cre ba캼na puan yok (Kullan캼c캼 "sadece yok oldu릇nda" dedi)
  SINGLE_LINE: 100,
  MULTI_LINE_BASE: 100,
  MULTI_LINE_BONUS: 25,
  STREAK_MULTIPLIER: 0.15,
};

export const CELL_MARGIN = 2; // H칲creler aras캼 bo륿uk

// Board Calculation
// We use the smaller of:
// 1. Width-based (Screen width - padding)
// 2. Height-based (55% of Screen height - padding) to ensure it fits vertically with ads/pieces

// Simplified robust version:
const sizeByWidth = (width - 40) / BOARD_SIZE;
const sizeByHeight = (height * 0.55) / BOARD_SIZE;

export const CELL_SIZE = Math.min(sizeByWidth, sizeByHeight);

export const CELL_BORDER_RADIUS = 4;

// Test Ad IDs (for development)
const TEST_AD_CONFIG = {
  interstitial: {
    android: "ca-app-pub-3940256099942544/1033173712",
    ios: "ca-app-pub-3940256099942544/4411468910",
  },
  banner: {
    android: "ca-app-pub-3940256099942544/6300978111",
    ios: "ca-app-pub-3940256099942544/2934735716",
  },
  native: {
    android: "ca-app-pub-3940256099942544/2247696110",
    ios: "ca-app-pub-3940256099942544/3986624511",
  },
};

// Production Ad IDs (for release builds)
const PROD_AD_CONFIG = {
  interstitial: {
    android: "ca-app-pub-5502183878891798/6177250595",
    ios: "ca-app-pub-5502183878891798/3358741489",
  },
  banner: {
    android: "ca-app-pub-5502183878891798/3247060847",
    ios: "ca-app-pub-5502183878891798/4671823158",
  },
  native: {
    android: "ca-app-pub-5502183878891798/8939145302",
    ios: "ca-app-pub-5502183878891798/6264880506",
  },
};

export const AD_CONFIG = __DEV__ ? TEST_AD_CONFIG : PROD_AD_CONFIG;
</file>

<file path="src/utils/gameLogic.ts">
import { BOARD_SIZE, SCORING } from "./constants";

export interface MoveResult {
  newBoard: (string | null)[][];
  placedBoard: (string | null)[][]; // The board state BEFORE clearing lines
  clearedRows: number[];
  clearedCols: number[];
  score: number;
  isCross: boolean;
  comboType: "SINGLE" | "DOUBLE" | "TRIPLE" | "QUAD" | "MEGA";
  totalCellsCleared: number;
}

export const processMove = (
  board: (string | null)[][],
  piece: number[][],
  row: number,
  col: number,
  color: string,
  currentStreak: number,
): MoveResult => {
  // 1. Board'un kopyas캼n캼 olu릆ur ve par칞ay캼 yerle릆ir
  let nextBoard = board.map((r) => [...r]);
  let cellsPlaced = 0;

  piece.forEach((pRow, rIdx) => {
    pRow.forEach((cell, cIdx) => {
      if (cell === 1) {
        nextBoard[row + rIdx][col + cIdx] = color;
        cellsPlaced++;
      }
    });
  });

  const clearedRows: number[] = [];
  const clearedCols: number[] = [];

  // 2. Sat캼rlar캼 Kontrol Et
  for (let r = 0; r < BOARD_SIZE; r++) {
    if (nextBoard[r].every((cell) => cell !== null)) clearedRows.push(r);
  }

  // 3. S칲tunlar캼 Kontrol Et
  for (let c = 0; c < BOARD_SIZE; c++) {
    let isFull = true;
    for (let r = 0; r < BOARD_SIZE; r++) {
      if (nextBoard[r][c] === null) {
        isFull = false;
        break;
      }
    }
    if (isFull) clearedCols.push(c);
  }

  // 4. Board'u Temizle (G칬rsel animasyon i칞in indexleri sakl캼yoruz)
  const finalBoard = nextBoard.map((r, rIdx) =>
    r.map((cell, cIdx) =>
      clearedRows.includes(rIdx) || clearedCols.includes(cIdx) ? null : cell,
    ),
  );

  // 5. Geli릀i Skor Hesaplama
  const totalLines = clearedRows.length + clearedCols.length;
  const isCross = clearedRows.length > 0 && clearedCols.length > 0;
  let moveScore = cellsPlaced * SCORING.BASE_CELL;

  if (totalLines > 0) {
    let lineBonus = totalLines * SCORING.LINE_CLEAR;
    // Multi-line bonus (2 sat캼r silmek 1+1'den daha de른rli olmal캼)
    lineBonus = Math.floor(
      lineBonus * Math.pow(totalLines, SCORING.MULTI_LINE_EXP - 1),
    );

    // Cross bonus
    if (isCross) lineBonus *= SCORING.CROSS_BONUS;

    // Streak bonus (칖st 칲ste hamleler)
    moveScore += lineBonus * (1 + currentStreak * 0.5);
  }

  return {
    newBoard: finalBoard,
    placedBoard: nextBoard,
    clearedRows,
    clearedCols,
    score: Math.floor(moveScore),
    isCross,
    totalCellsCleared:
      clearedRows.length * BOARD_SIZE +
      clearedCols.length * BOARD_SIZE -
      clearedRows.length * clearedCols.length,
    comboType:
      totalLines <= 1
        ? "SINGLE"
        : totalLines === 2
          ? "DOUBLE"
          : totalLines === 3
            ? "TRIPLE"
            : "MEGA",
  };
};
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

# generated native folders
/ios
/android

*.ipa
*.apk
*.aab
</file>

<file path="app.json">
{
  "expo": {
    "name": "grid-grin",
    "slug": "grid-grin",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "gridgrin",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "icon": {
        "light": "./assets/images/icon.png",
        "dark": "./assets/images/ios-dark.png",
        "tinted": "./assets/images/ios-tinted.png"
      },
      "buildNumber": "1",
      "supportsTablet": true,
      "bundleIdentifier": "com.eoist.gridgrin",
      "infoPlist": {
        "NSUserTrackingUsageDescription": "Bu izin, size ilgi alanlar캼n캼za uygun reklamlar g칬stermek i칞in kullan캼lacakt캼r.",
        "ITSAppUsesNonExemptEncryption": false
      },
      "entitlements": {
        "com.apple.developer.networking.wifi-info": true,
        "com.apple.developer.game-center": true
      }
    },
    "android": {
      "versionCode": 1,
      "package": "com.eoist.gridgrin",
      "adaptiveIcon": {
        "backgroundColor": "#E6F4FE",
        "foregroundImage": "./assets/images/adaptive-icon.png"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false
    },
    "web": {
      "output": "static",
      "favicon": "./assets/images/icon.png"
    },
    "plugins": [
      "expo-router",
      [
        "react-native-google-mobile-ads",
        {
          "androidAppId": "ca-app-pub-5502183878891798~5873224185",
          "iosAppId": "ca-app-pub-5502183878891798~7297986491"
        }
      ],
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon-light.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff",
          "dark": {
            "image": "./assets/images/splash-icon-dark.png",
            "backgroundColor": "#000000"
          }
        }
      ],
      [
        "expo-build-properties",
        {
          "ios": {
            "useFrameworks": "static",
            "deploymentTarget": "15.4"
          },
          "android": {
            "compileSdkVersion": 35,
            "targetSdkVersion": 35,
            "buildToolsVersion": "35.0.0",
            "enableProguardInReleaseBuilds": true,
            "enableShrinkResourcesInReleaseBuilds": true,
            "enableR8InReleaseBuilds": true
          }
        }
      ],
      [
        "expo-tracking-transparency",
        {
          "userTrackingPermission": "Bu izin, size ilgi alanlar캼n캼za uygun reklamlar g칬stermek i칞in kullan캼lacakt캼r."
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    },
    "extra": {
      "router": {},
      "eas": {
        "projectId": "b666c5ef-3e6f-4f31-a109-93433efede06"
      }
    }
  }
}
</file>

<file path="app/_layout.tsx">
import { CustomSplashScreen } from "@/src/components/Splash/CustomSplashScreen";
import { Stack } from "expo-router";
import { useState } from "react";
import { StatusBar } from "react-native";
import { GestureHandlerRootView } from "react-native-gesture-handler";

export default function RootLayout() {
  const [isSplashFinished, setSplashFinished] = useState(false);

  if (!isSplashFinished) {
    return <CustomSplashScreen onFinish={() => setSplashFinished(true)} />;
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <StatusBar barStyle="light-content" />
      <Stack screenOptions={{ headerShown: false }} />
    </GestureHandlerRootView>
  );
}
</file>

<file path="app/index.tsx">
import { useGameStore } from "@/src/store/useGameStore";
import { THEME } from "@/src/utils/constants";
import { useRouter } from "expo-router";
import { requestTrackingPermissionsAsync } from "expo-tracking-transparency";
import React, { useEffect } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import Animated, { FadeInDown } from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";

export default function MainMenu() {
  const { top, bottom } = useSafeAreaInsets();
  const router = useRouter();
  const { loadGame, hasSavedGame, resetGame, score, leaderboard } =
    useGameStore();

  useEffect(() => {
    (async () => {
      const { status } = await requestTrackingPermissionsAsync();
      if (status === "granted") {
        console.log("Yay! I have user permission to track data");
      }
    })();
  }, []);

  useEffect(() => {
    loadGame(); // Check for saved game on mount
  }, []);

  const handleNewGame = () => {
    resetGame();
    router.replace("/game");
  };

  const handleContinue = () => {
    router.replace("/game");
  };

  const [best, second, third] = leaderboard;

  return (
    <View
      style={[
        styles.container,
        { paddingTop: top + 40, paddingBottom: bottom + 40 },
      ]}
    >
      <Animated.Text
        entering={FadeInDown.delay(200).springify()}
        style={styles.title}
      >
        GRID GRIN
      </Animated.Text>

      {/* Leaderboard Section */}
      <Animated.View
        entering={FadeInDown.delay(300)}
        style={styles.lbContainer}
      >
        <Text style={styles.bestLabel}>EN 캻Y캻 SKORLAR</Text>
        <Text style={styles.bestScore}>{best}</Text>

        {second > 0 && <Text style={styles.secondScore}>{second}</Text>}

        {third > 0 && <Text style={styles.thirdScore}>{third}</Text>}
      </Animated.View>

      <Animated.View
        entering={FadeInDown.delay(500).springify()}
        style={styles.menuContainer}
      >
        {hasSavedGame && (
          <TouchableOpacity
            style={[styles.button, styles.continueButton]}
            onPress={handleContinue}
            activeOpacity={0.8}
          >
            <Text style={styles.buttonText}>DEVAM ET</Text>
            <Text style={styles.scoreText}>{score} Puan</Text>
          </TouchableOpacity>
        )}

        <TouchableOpacity
          style={[styles.button, styles.newGameButton]}
          onPress={handleNewGame}
          activeOpacity={0.8}
        >
          <Text style={[styles.buttonText, styles.newGameText]}>BA뢻A</Text>
        </TouchableOpacity>
      </Animated.View>

      <Animated.Text entering={FadeInDown.delay(700)} style={styles.version}>
        v1.0.0
      </Animated.Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: THEME.BACKGROUND,
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: {
    fontSize: 64,
    fontWeight: "900",
    color: THEME.TEXT_PRIMARY,
    letterSpacing: 4,
    textAlign: "center",
    textShadowColor: "rgba(0,0,0,0.2)",
    textShadowOffset: { width: 0, height: 4 },
    textShadowRadius: 10,
  },
  lbContainer: {
    alignItems: "center",
    marginBottom: 20,
    gap: 0, // Dikey bo륿uklar캼 manuel kontrol edece를z veya gap verebiliriz
    minHeight: 120, // Sabit bir alan kaplas캼n ki UI z캼plamas캼n
    justifyContent: "center",
  },
  bestLabel: {
    color: THEME.TEXT_SECONDARY,
    fontSize: 14,
    fontWeight: "bold",
    letterSpacing: 2,
    marginBottom: 8,
  },
  bestScore: {
    color: THEME.TEXT_PRIMARY,
    fontSize: 56, // Biraz daha b칲y칲tt칲m
    fontWeight: "900",
    textShadowColor: "rgba(0,0,0,0.2)",
    textShadowOffset: { width: 0, height: 2 },
    textShadowRadius: 4,
    lineHeight: 64,
  },
  secondScore: {
    color: THEME.TEXT_PRIMARY, // Biraz daha soluk olabilir ama primary kals캼n
    fontSize: 32,
    fontWeight: "800",
    opacity: 0.8,
    marginTop: 4,
  },
  thirdScore: {
    color: THEME.TEXT_PRIMARY,
    fontSize: 24,
    fontWeight: "700",
    opacity: 0.6,
    marginTop: 2,
  },
  menuContainer: {
    width: "100%",
    paddingHorizontal: 40,
    gap: 20,
    alignItems: "center",
  },
  button: {
    width: "100%",
    paddingVertical: 24,
    borderRadius: 24,
    alignItems: "center",
    justifyContent: "center",
    elevation: 0, // No shadow
    shadowOpacity: 0, // No shadow
  },
  continueButton: {
    backgroundColor: THEME.SURFACE_LIGHT,
    borderWidth: 1,
    borderColor: THEME.TEXT_SECONDARY,
  },
  newGameButton: {
    backgroundColor: THEME.BUTTON_PRIMARY,
  },
  buttonText: {
    fontSize: 24,
    fontWeight: "900",
    color: THEME.BUTTON_TEXT,
    letterSpacing: 1,
  },
  newGameText: {
    color: THEME.BUTTON_TEXT,
  },
  scoreText: {
    fontSize: 14,
    fontWeight: "700",
    color: THEME.TEXT_SECONDARY,
    marginTop: 4,
  },
  version: {
    color: THEME.TEXT_MUTED,
    fontSize: 12,
  },
});
</file>

<file path="package.json">
{
  "name": "grid-grin",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-navigation/bottom-tabs": "^7.4.0",
    "@react-navigation/elements": "^2.6.3",
    "@react-navigation/native": "^7.1.8",
    "expo": "~54.0.0",
    "expo-build-properties": "~1.0.10",
    "expo-constants": "~18.0.13",
    "expo-font": "~14.0.11",
    "expo-haptics": "~15.0.8",
    "expo-image": "~3.0.11",
    "expo-linking": "~8.0.11",
    "expo-router": "~6.0.22",
    "expo-splash-screen": "~31.0.13",
    "expo-status-bar": "~3.0.9",
    "expo-symbols": "~1.0.8",
    "expo-system-ui": "~6.0.9",
    "expo-tracking-transparency": "~6.0.8",
    "expo-updates": "~29.0.16",
    "expo-web-browser": "~15.0.10",
    "lottie-react-native": "~7.3.1",
    "lucide-react-native": "^0.563.0",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-google-mobile-ads": "^16.0.3",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1",
    "zustand": "^5.0.10"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "babel-preset-expo": "~54.0.10",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "typescript": "~5.9.2"
  },
  "private": true
}
</file>

<file path="README.md">
# Welcome to your Expo app 游녦

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
   npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.
#   g r i d - g r i n  
 
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "jsx": "react-native",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["**/*.ts", "**/*.tsx", ".expo/types/**/*.ts", "expo-env.d.ts"]
}
</file>

</files>
